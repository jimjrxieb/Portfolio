{"instruction": "What are the JSA agent variants and their primary responsibilities?", "input": "Explain the difference between jsa-devsec, jsa-infrasec, and jsa-secops agents", "output": "JSA has three specialized agent variants in the Iron Legion:\n\n**jsa-devsec (DevSecOps Agent)**\n- Focus: Application security and CI/CD pipeline integration\n- Runs as a 24/7 daemon watching GitHub Actions webhooks\n- 8 scanners: gitleaks, bandit, semgrep, trivy, eslint, hadolint, checkov, safety\n- Auto-deploys D-rank defense playbooks (Gatekeeper/Kyverno policies)\n- LogBrain normalizes scanner outputs, EventProcessor routes by rank\n\n**jsa-infrasec (Infrastructure Security Agent)**\n- Focus: Kubernetes, Cloud, IaC, Policy, Secrets, and Compliance\n- 117 modules across 6 security domains\n- K8sGPT-style AnalyzerResult/Failure model\n- DomainLoader for dynamic module loading\n- BlastRadiusAnalyzer assesses fix impact before applying\n- Runs in K8s cluster with comprehensive RBAC\n\n**jsa-secops (SecOps Agent) - Planned**\n- Focus: Runtime security monitoring and incident response\n- Falco, GuardDuty, CloudTrail integration\n- B/S-rank incident response automation\n\nAll agents share:\n- Rank-based fix permissions (E/D/C/B/S)\n- JADE supervisor integration for C-rank approvals\n- Helm chart deployment pattern", "metadata": {"domain": "jsa-architecture", "task_type": "knowledge", "skill_level": "C-rank", "agents": ["jsa-devsec", "jsa-infrasec", "jsa-secops"]}}
{"instruction": "What scanners does jsa-devsec use?", "input": "List all security scanners in jsa-devsec", "output": "jsa-devsec runs 8 security scanners in its 24/7 daemon mode:\n\n**Secrets Detection:**\n- Gitleaks - Detects hardcoded secrets, API keys, tokens in code\n\n**SAST (Static Analysis):**\n- Bandit - Python security analysis (SQL injection, XSS, command injection)\n- Semgrep - Multi-language SAST with custom rules\n- ESLint - JavaScript/TypeScript security linting\n\n**Container & Dependencies:**\n- Trivy - Container images, dependencies, SBOM generation\n- Safety - Python dependency CVE scanning\n\n**Infrastructure:**\n- Hadolint - Dockerfile best practices and security\n- Checkov - IaC security scanning (Terraform, CloudFormation, Helm)\n\nAll scanner outputs are normalized by LogBrain into a unified format, then routed by EventProcessor based on rank (E/D/C/B/S) for appropriate handling.", "metadata": {"domain": "jsa-devsec", "task_type": "scanner-inventory", "skill_level": "D-rank", "agent": "jsa-devsec"}}
{"instruction": "What domains does jsa-infrasec cover?", "input": "List all security domains in jsa-infrasec", "output": "jsa-infrasec covers 6 security domains with 117 total modules:\n\n**Kubernetes (k8s_ prefix)**\n- 15+ analyzers: pod security, RBAC, network policies, images, probes, resources\n- 12+ fixers: security context, resource limits, network policy generator\n- Scanners: trivy, kubescape, polaris\n\n**Cloud - AWS (cloud_ prefix)**\n- 9 analyzers: IAM, S3, EC2, VPC, GuardDuty, SecurityHub, CloudTrail, KMS, Config\n- 4 fixers: IAM, S3, EC2, VPC remediation\n- Scanners: prowler, checkov\n\n**IaC (iac_ prefix)**\n- 5 analyzers: Terraform, Helm, CloudFormation, drift detection, compliance\n- 5 fixers: Terraform, Helm, CloudFormation, drift reconciler, conftest\n- Scanners: tfsec, checkov\n\n**Policy (policy_ prefix)**\n- 6 analyzers: Rego, constraints, coverage, conflicts, OPA testing, mutations\n- 6 fixers: Rego generator, constraint creator, Kyverno creator, mutations, exceptions, tuner\n- Scanners: conftest, opa\n\n**Secrets (secrets_ prefix)**\n- 3 analyzers: rotation, exposure, encryption\n- 3 fixers: secret rotator, sealed secret converter, secret migrator\n- Scanners: gitleaks\n\n**Compliance (compliance_ prefix)**\n- 8 analyzers: gap analysis, control mapper, evidence collector, framework mappings\n- Frameworks: CIS, NIST 800-53, SOC2, PCI-DSS, HIPAA, FedRAMP", "metadata": {"domain": "jsa-infrasec", "task_type": "domain-inventory", "skill_level": "C-rank", "agent": "jsa-infrasec"}}
{"instruction": "How does jsa-devsec daemon mode work?", "input": "Explain the 24/7 daemon mode in jsa-devsec", "output": "jsa-devsec's daemon mode runs continuously watching for security events:\n\n**Three Input Sources:**\n1. GHA Webhook Watcher - Monitors GitHub Actions workflow completions\n2. Scanner Directory Watcher - Watches for new scanner output files\n3. Manual CLI Trigger - On-demand scans via command line\n\n**Processing Pipeline:**\n```\nInput -> LogBrain (normalize) -> EventProcessor (rank routing)\n                                      |\n            +-------------------------+-------------------------+\n            v                         v                         v\n        E/D Rank                  C Rank                    B/S Rank\n        Auto-Fix              JADE Approval                 Escalate\n            |                       |\n            v                       v\n    PlaybookExecutor           Approval Queue\n    (deploy defenses)\n```\n\n**Command:**\n```bash\npython3 src/main.py daemon \\\n  --instance 02-instance \\\n  --slot slot-3 \\\n  --watch-gha jimjrxieb/Portfolio\n```\n\n**Key Features:**\n- LogBrain normalizes all scanner outputs to unified format\n- EventProcessor classifies findings by rank\n- E/D rank issues auto-fixed with defense playbooks deployed\n- C rank routed to JADE for approval\n- B/S rank escalated to human experts", "metadata": {"domain": "jsa-devsec", "task_type": "daemon-mode", "skill_level": "C-rank", "agent": "jsa-devsec"}}
{"instruction": "What defense playbooks does jsa-devsec deploy?", "input": "List the D-rank defense playbooks", "output": "jsa-devsec auto-deploys defensive policies for D-rank findings:\n\n**Playbook: block-secrets**\n- Trigger: hardcoded-secret finding\n- Deploys: Gatekeeper constraint blocking secrets in manifests\n- Prevents future secrets from being deployed to cluster\n\n**Playbook: require-nonroot**\n- Trigger: privileged-container finding\n- Deploys: Kyverno policy requiring runAsNonRoot: true\n- Enforces non-root containers cluster-wide\n\n**Playbook: default-deny**\n- Trigger: missing-network-policy finding\n- Deploys: NetworkPolicy with default deny ingress/egress\n- Establishes zero-trust network baseline\n\n**Playbook: require-limits**\n- Trigger: no-resource-limits finding\n- Deploys: Gatekeeper mutation adding default limits\n- Prevents resource exhaustion attacks\n\n**Playbook: require-probes**\n- Trigger: missing-health-probes finding\n- Deploys: Policy requiring liveness/readiness probes\n\n**Playbook: trusted-registries**\n- Trigger: untrusted-image-registry finding\n- Deploys: Constraint allowing only approved registries\n\nAll D-rank playbooks deploy automatically. C-rank playbooks require JADE approval before deployment.", "metadata": {"domain": "jsa-devsec", "task_type": "defense-playbooks", "skill_level": "D-rank", "agent": "jsa-devsec"}}
{"instruction": "What is JADE and how does it relate to JSA?", "input": "Explain JADE supervisor role", "output": "JADE (JADE AI Decision Engine) is the C-rank supervisor in the Iron Legion hierarchy:\n\n**Hierarchy:**\n```\nJimmie (Human)     - Principal (A-S rank)\n    |\nClaude Code        - Operator (B rank, builds everything)\n    |\nJADE               - Supervisor (C rank authority ceiling)\n    |\nJSA Agents         - Workers (E-D rank autonomous)\n```\n\n**JADE's Responsibilities:**\n- Reviews C-rank findings from jsa-devsec and jsa-infrasec\n- Generates fix proposals for approval\n- Executes defense playbooks after approval\n- Has HARD authority ceiling at C-rank (cannot auto-approve B/S)\n\n**Key Components:**\n- LogBrain: Normalizes scanner outputs from multiple tools\n- RankClassifier: ML-powered classification (sklearn + XGBoost)\n- PlaybookExecutor: Deploys Gatekeeper/Kyverno/NetworkPolicy\n- FeedbackLogger: Records decisions for learning (725+ historical entries)\n\n**Workflow:**\n1. JSA agent detects finding\n2. RankClassifier assigns E/D/C/B/S rank\n3. E/D: JSA auto-fixes\n4. C: JADE reviews, approves/denies\n5. B/S: Escalated to human expert\n\nJADE learns from historical decisions to improve future accuracy.", "metadata": {"domain": "jade-supervisor", "task_type": "architecture", "skill_level": "C-rank", "agents": ["jade", "jsa-devsec", "jsa-infrasec"]}}
{"instruction": "How does the rank system work?", "input": "Explain the E/D/C/B/S rank system", "output": "The Iron Legion uses a rank system to determine automation level:\n\n**E-Rank (100% automation)**\n- Handler: JSA auto-fix immediately\n- Examples: Hardcoded secrets, formatting issues, missing .gitignore\n- No human involvement needed\n\n**D-Rank (70-90% automation)**\n- Handler: JSA auto-fix + defense playbook deployment\n- Examples: Dependency CVEs, missing policies, basic K8s misconfigs\n- Logs action but no approval needed\n- Triggers protective policies (Gatekeeper, Kyverno, NetworkPolicy)\n\n**C-Rank (40-70% automation)**\n- Handler: JADE approval required\n- Examples: Multi-file config changes, RBAC modifications, IaC changes\n- JADE reviews and approves/denies\n- JADE's maximum authority level\n\n**B-Rank (20-40% automation)**\n- Handler: Human + JADE assistance\n- Examples: Architecture decisions, cross-service changes\n- Escalated to human expert with JADE context\n\n**S-Rank (0-5% automation)**\n- Handler: Human only\n- Examples: Compliance sign-off, org-wide policy, incident response\n- Immediate escalation, no autonomous action\n\nRank is determined by RankClassifier using sklearn + XGBoost trained on 725+ historical decisions.", "metadata": {"domain": "rank-system", "task_type": "knowledge", "skill_level": "C-rank", "agents": ["jade", "jsa-devsec", "jsa-infrasec"]}}
{"instruction": "How do I deploy jsa-infrasec?", "input": "Commands to deploy jsa-infrasec to Kubernetes", "output": "Deploy jsa-infrasec to your Kubernetes cluster:\n\n**1. Create namespace:**\n```bash\nkubectl create namespace jsa-infrasec\n```\n\n**2. Deploy with Helm:**\n```bash\nhelm upgrade --install jsa-infrasec \\\n  ./charts/jsa-infrasec \\\n  --namespace jsa-infrasec \\\n  --set gpcopilot.instance=02-instance \\\n  --set gpcopilot.slot=slot-3\n```\n\n**3. Configure domains (values.yaml):**\n```yaml\ndomains:\n  kubernetes:\n    enabled: true\n    namespaces: [\"*\"]\n  policy:\n    enabled: true\n    frameworks: [opa, gatekeeper, kyverno]\n  iac:\n    enabled: true\n  cloud:\n    enabled: true\n  secrets:\n    enabled: true\n  compliance:\n    enabled: true\n    frameworks: [cis, nist, soc2]\n```\n\n**4. Verify deployment:**\n```bash\nkubectl get pods -n jsa-infrasec\nkubectl logs -n jsa-infrasec deployment/jsa-infrasec -f\n```\n\n**5. Check metrics:**\n```bash\nkubectl port-forward -n jsa-infrasec svc/jsa-infrasec 9100:9100\ncurl http://localhost:9100/metrics\n```\n\njsa-infrasec requires ClusterRole permissions for cross-namespace scanning.", "metadata": {"domain": "jsa-deployment", "task_type": "deployment-commands", "skill_level": "C-rank", "agent": "jsa-infrasec"}}
{"instruction": "What is K8sGPT-style analysis?", "input": "Explain the AnalyzerResult/Failure model", "output": "jsa-infrasec uses K8sGPT-style structured analysis for consistent output:\n\n**AnalyzerResult Model:**\n```python\n@dataclass\nclass AnalyzerResult:\n    kind: str              # Resource type (Pod, Deployment, etc.)\n    name: str              # Resource name (namespace/name)\n    errors: List[Failure]  # Detected issues\n    parent_object: Optional[str]  # Owning resource\n```\n\n**Failure Model:**\n```python\n@dataclass\nclass Failure:\n    text: str              # Error description\n    sensitive: List[str]   # Data to redact in logs\n```\n\n**Benefits:**\n1. Consistent output format across all 117 modules\n2. Easy aggregation and reporting\n3. Sensitive data handling for audit logs\n4. Parent object tracking for blast radius analysis\n\n**Example Output:**\n```json\n{\n  \"kind\": \"Deployment\",\n  \"name\": \"production/api-server\",\n  \"errors\": [\n    {\"text\": \"Container running as root\", \"sensitive\": []},\n    {\"text\": \"Missing resource limits\", \"sensitive\": []}\n  ],\n  \"parent_object\": null\n}\n```\n\nBlastRadiusAnalyzer uses this structure to count affected pods, services, and assess fix risk before applying changes.", "metadata": {"domain": "jsa-infrasec", "task_type": "architecture", "skill_level": "C-rank", "agent": "jsa-infrasec"}}
{"instruction": "What is the BlastRadiusAnalyzer?", "input": "Explain blast radius analysis in jsa-infrasec", "output": "BlastRadiusAnalyzer assesses the impact of fixes before applying them:\n\n**What It Analyzes:**\n- Number of affected pods\n- Number of affected services\n- Number of affected ingresses\n- Whether resource is in critical namespace (kube-system, production)\n- Replica count of affected deployments\n- Dependency chains (what depends on this resource)\n\n**Risk Scoring:**\n- LOW: Single pod, non-critical namespace, no dependencies\n- MEDIUM: Multiple pods or has downstream services\n- HIGH: Production namespace or many dependencies\n- CRITICAL: kube-system or cluster-wide impact\n\n**How It's Used:**\n1. Analyzer detects issue (e.g., missing security context)\n2. Fixer proposes fix (add runAsNonRoot: true)\n3. BlastRadiusAnalyzer calculates impact\n4. If HIGH/CRITICAL, escalate to C-rank for JADE approval\n5. If LOW/MEDIUM and D-rank finding, apply automatically\n\n**Example:**\n```python\nblast_radius = BlastRadiusAnalyzer.analyze(\n    resource=\"deployment/api-server\",\n    proposed_fix=\"add-security-context\"\n)\n# Returns: {\"risk\": \"MEDIUM\", \"affected_pods\": 3, \"affected_services\": 1}\n```\n\nThis prevents automated fixes from causing widespread outages.", "metadata": {"domain": "jsa-infrasec", "task_type": "architecture", "skill_level": "C-rank", "agent": "jsa-infrasec"}}
{"instruction": "What is the DomainLoader?", "input": "Explain dynamic module loading in jsa-infrasec", "output": "DomainLoader dynamically loads all 117 modules in jsa-infrasec by prefix:\n\n**How It Works:**\n1. Scans src/analyzers/, src/fixers/, src/watchers/, src/scanners/\n2. Groups files by domain prefix (k8s_, cloud_, iac_, policy_, secrets_, compliance_)\n3. Returns organized structure for the agent loop\n\n**Structure:**\n```python\ndomains = DomainLoader.load_all()\n# Returns:\n{\n  \"kubernetes\": {\n    \"analyzers\": [k8s_pod_analyzer, k8s_rbac, ...],\n    \"fixers\": [k8s_security_context, k8s_resource_limits, ...],\n    \"watchers\": [k8s_events, k8s_admission, ...]\n  },\n  \"cloud\": {\n    \"analyzers\": [cloud_iam_analyzer, cloud_s3_analyzer, ...],\n    \"fixers\": [cloud_iam_fixer, cloud_s3_fixer, ...],\n    \"watchers\": [cloud_iam_watcher, ...]\n  },\n  # ... policy, iac, secrets, compliance\n}\n```\n\n**Agent Loop Integration:**\n```python\nfor domain_name, components in domains.items():\n    if scheduler.should_scan(domain_name):\n        for analyzer in components[\"analyzers\"]:\n            findings = await analyzer.analyze()\n            # Route to appropriate fixer\n```\n\nDomainLoader enables:\n- Adding new modules by just creating files with the right prefix\n- Selective domain enablement via config\n- Clean separation of security concerns", "metadata": {"domain": "jsa-infrasec", "task_type": "architecture", "skill_level": "C-rank", "agent": "jsa-infrasec"}}
{"instruction": "How many modules does jsa-infrasec have?", "input": "Total module count in jsa-infrasec", "output": "jsa-infrasec contains 117 modules across 6 domains:\n\n**Module Breakdown:**\n\n| Domain | Analyzers | Fixers | Watchers | Scanners | Total |\n|--------|-----------|--------|----------|----------|-------|\n| Kubernetes | 15 | 14 | 5 | 3 | 37 |\n| Cloud (AWS) | 9 | 4 | 4 | 2 | 19 |\n| IaC | 5 | 5 | 3 | 2 | 15 |\n| Policy | 6 | 6 | 3 | 2 | 17 |\n| Secrets | 3 | 3 | 3 | 1 | 10 |\n| Compliance | 8 | 0 | 0 | 0 | 8 |\n| Templates | 11 | - | - | - | 11 |\n| **Total** | **57** | **32** | **18** | **10** | **117** |\n\n**Code Metrics:**\n- Total lines of code: ~28,000\n- Main agent.py: 1,700+ lines\n- Largest analyzer: k8s_kubernetes_analyzer.py\n\n**Compliance Templates:**\n- policy_pss.py, policy_cis.py, policy_nist.py, policy_soc2.py, policy_pci.py\n- compliance_cis.py, compliance_nist.py, compliance_soc2.py, compliance_pci.py, compliance_hipaa.py, compliance_fedramp.py\n\nAll modules follow consistent patterns and are dynamically loaded by DomainLoader.", "metadata": {"domain": "jsa-infrasec", "task_type": "metrics", "skill_level": "D-rank", "agent": "jsa-infrasec"}}
{"instruction": "How do I run a one-shot scan with jsa-devsec?", "input": "Command to scan a repository once", "output": "Run a one-shot scan with jsa-devsec:\n\n**Basic Scan:**\n```bash\ncd GP-BEDROCK-AGENTS/jsa-devsec\npython3 src/main.py scan --target /path/to/repo\n```\n\n**Verbose Output:**\n```bash\npython3 src/main.py scan --target /path/to/repo -v\n```\n\n**Scan Specific Scanners:**\n```bash\npython3 src/main.py scan --target /path/to/repo --scanners gitleaks,bandit,semgrep\n```\n\n**Dry-Run (no fixes applied):**\n```bash\npython3 src/main.py scan --target /path/to/repo --dry-run\n```\n\n**Output Options:**\n```bash\n# JSON output\npython3 src/main.py scan --target /path/to/repo --output json\n\n# Save to file\npython3 src/main.py scan --target /path/to/repo --output-file scan-results.json\n```\n\n**What Runs:**\n1. All 8 scanners execute against target\n2. LogBrain normalizes outputs\n3. RankClassifier assigns E/D/C/B/S ranks\n4. Findings displayed with recommended actions\n\n**Example Output:**\n```\n[E-RANK] Hardcoded API key in config.py:42 - AUTO-FIX available\n[D-RANK] CVE-2024-1234 in requests==2.28.0 - Upgrade to 2.31.0\n[C-RANK] Missing NetworkPolicy for api-deployment - Requires approval\n```", "metadata": {"domain": "jsa-devsec", "task_type": "usage", "skill_level": "D-rank", "agent": "jsa-devsec"}}
