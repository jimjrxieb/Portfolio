{"instruction": "What are the two JSA agent variants and their primary responsibilities?", "input": "Explain the difference between jsa-ci and jsa-devsecops agents", "output": "JSA has two specialized agent variants:\n\n**jsa-ci (CI/CD Security Agent)**\n- Focus: Application security in CI/CD pipelines\n- Handles: SAST, secrets detection, dependency scanning, code quality\n- Deployment: Runs as K8s pod watching GitHub webhooks and PR events\n- Workload: ~30% of security automation tasks\n\n**jsa-devsecops (DevSecOps Agent)**\n- Focus: Infrastructure and runtime security (GuidePoint specialty)\n- Handles: Kubernetes, Policy-as-Code, IaC, Cloud, Secrets Management, Compliance\n- Deployment: Runs as 24/7 K8s pod with domain schedulers\n- Workload: ~70% of security automation tasks\n\nBoth agents share:\n- Helm chart deployment pattern\n- CronJobs for log-sync and health-report\n- Slack notifications\n- State management via GP-Copilot API\n- Rank-based fix permissions (E/D/C/B/S)", "metadata": {"domain": "jsa-architecture", "task_type": "knowledge", "skill_level": "C-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What scanners does jsa-ci use?", "input": "List all security scanners in jsa-ci", "output": "jsa-ci uses these scanners in src/scanners/:\n\n**Secrets Detection:**\n- gitleaks_scan_npc.py - Detects hardcoded secrets, API keys, tokens\n\n**SAST (Static Analysis):**\n- bandit_scan_npc.py - Python security analysis (SQL injection, XSS, command injection)\n- semgrep_scan_npc.py - Multi-language SAST with custom rules\n- eslint_scan_npc.py - JavaScript/TypeScript security linting\n\n**Code Quality:**\n- hadolint_scan_npc.py - Dockerfile best practices\n\n**CI/CD Security:**\n- gha_scanner_npc.py - GitHub Actions security (unpinned actions, injection risks)\n- github_api_npc.py - GitHub API integration for PR comments, status checks\n\nAll scanners follow the BaseNPC pattern with standardized run() method returning normalized findings.", "metadata": {"domain": "jsa-ci", "task_type": "scanner-inventory", "skill_level": "D-rank", "agent": "jsa-ci"}}
{"instruction": "What scanners does jsa-devsecops use?", "input": "List all security scanners in jsa-devsecops", "output": "jsa-devsecops uses these scanners in src/scanners/:\n\n**Kubernetes Security:**\n- kubescape_scan_npc.py - K8s security posture (NSA, MITRE frameworks)\n- polaris_scan_npc.py - K8s best practices and workload validation\n- kubebench_scan_npc.py - CIS Kubernetes benchmarks\n- kubectl_diagnostics_npc.py - Runtime K8s diagnostics\n\n**Infrastructure as Code:**\n- checkov_scan_npc.py - Terraform, CloudFormation, Helm scanning\n- tfsec_scan_npc.py - Terraform-specific security\n- conftest_scan_npc.py - OPA/Rego policy testing\n\n**Vulnerability Scanning:**\n- trivy_scan_npc.py - Container images, filesystems, IaC, SBOM\n- grype_scan_npc.py - SCA vulnerability scanning\n- snyk_scan_npc.py - Commercial SCA integration\n\n**Cloud Security:**\n- prowler_scan_npc.py - AWS security auditing\n- infrastructure_scanner_npc.py - Multi-cloud infrastructure scanning", "metadata": {"domain": "jsa-devsecops", "task_type": "scanner-inventory", "skill_level": "D-rank", "agent": "jsa-devsecops"}}
{"instruction": "What can jsa-ci fix automatically?", "input": "Describe jsa-ci fixer capabilities", "output": "jsa-ci fixers are in src/fixers/ and handle application-level remediation:\n\n**Secrets Fixes (D-rank, auto-fix):**\n- Remove hardcoded secrets from code\n- Add patterns to .gitignore\n- Rotate exposed credentials via API\n\n**Dependency Fixes (D-rank, auto-fix):**\n- yarn upgrade / npm update for JS vulnerabilities\n- pip-compile / poetry update for Python\n- Generate lock files with fixed versions\n\n**Code Fixes (C-rank, approval required):**\n- SQL injection: Parameterized queries\n- XSS: Output encoding\n- Command injection: Input sanitization\n- Path traversal: Path validation\n\n**CI/CD Fixes (D-rank, auto-fix):**\n- Pin GitHub Actions to SHA\n- Fix workflow injection vulnerabilities\n- Add security scanning steps to pipelines\n\nFix orchestration via fix_orchestrator.py which coordinates multiple fixers per finding.", "metadata": {"domain": "jsa-ci", "task_type": "fixer-inventory", "skill_level": "C-rank", "agent": "jsa-ci"}}
{"instruction": "What can jsa-devsecops fix automatically?", "input": "Describe jsa-devsecops fixer capabilities", "output": "jsa-devsecops fixers are organized by domain in src/fixers/:\n\n**Kubernetes Fixes (k8s_*):**\n- k8s_pod_patcher_npc.py - Add security contexts, resource limits\n- k8s_network_policy_generator_npc.py - Generate NetworkPolicies\n- k8s_deployment_updater_npc.py - Fix deployment misconfigs\n- k8s_kubernetes_fixer_npc.py - General K8s remediation\n- k8s_rbac_scoper.py - Scope down overly permissive RBAC\n- k8s_probe_adder.py - Add liveness/readiness probes\n- k8s_resource_limits.py - Add CPU/memory limits\n- k8s_security_context.py - Add runAsNonRoot, drop capabilities\n- k8s_pod_security_enforcer.py - Enforce Pod Security Standards\n\n**Policy Fixes (policy_*):**\n- policy_rego_generator.py - Generate OPA/Rego policies\n- policy_constraint_creator.py - Create Gatekeeper constraints\n- policy_kyverno_creator.py - Generate Kyverno policies\n- policy_mutation_creator.py - Create policy mutations\n- policy_exception_manager.py - Handle policy exceptions\n\n**IaC Fixes (iac_*):**\n- iac_terraform_fixer.py - Fix Terraform misconfigs\n- iac_helm_fixer.py - Fix Helm chart issues\n- iac_conftest_fixer_npc.py - Fix OPA policy violations\n- iac_cloudformation_fixer.py - Fix CloudFormation templates\n- iac_drift_reconciler.py - Reconcile infrastructure drift\n\n**Cloud Fixes (cloud_*):**\n- cloud_iam_fixer.py - Fix IAM policy issues\n- cloud_s3_fixer.py - Fix S3 bucket configs\n- cloud_ec2_fixer.py - Fix EC2 security groups\n- cloud_vpc_fixer.py - Fix VPC configurations\n\n**Secrets Fixes (secrets_*):**\n- secrets_secret_rotator.py - Rotate secrets\n- secrets_sealed_secret_converter.py - Convert to SealedSecrets\n- secrets_secret_migrator.py - Migrate secrets to Vault", "metadata": {"domain": "jsa-devsecops", "task_type": "fixer-inventory", "skill_level": "C-rank", "agent": "jsa-devsecops"}}
{"instruction": "How are JSA agents deployed to Kubernetes?", "input": "Explain JSA Helm chart deployment", "output": "Both JSA agents deploy via Helm charts in GP-BEDROCK-AGENTS/charts/:\n\n**jsa-ci Deployment:**\n```bash\nhelm upgrade --install jsa-ci ./charts/jsa-ci \\\n  --namespace portfolio \\\n  --set gpcopilot.instance=02-instance \\\n  --set gpcopilot.slot=slot-3\n```\n\n**jsa-devsecops Deployment:**\n```bash\nhelm upgrade --install jsa-devsecops ./charts/jsa-devsecops \\\n  --namespace portfolio \\\n  --set gpcopilot.instance=02-instance \\\n  --set gpcopilot.slot=slot-3\n```\n\n**Key Helm Values:**\n- agent.rank: C (determines RBAC and auto-fix permissions)\n- agent.autoFix: true/false\n- agent.dryRun: true for testing\n- gpcopilot.endpoint: GP-GUI API URL\n- gpcopilot.instance/slot: Target project location\n- domains.*: Enable/disable security domains\n- notifications.slack.webhookUrlSecret: Slack integration\n\n**Resources Created:**\n- Deployment (main agent pod)\n- ServiceAccount with RBAC\n- CronJobs (log-sync, health-report, cve-tracker)\n- ConfigMap for agent config\n- NetworkPolicy for traffic control\n- ServiceMonitor for Prometheus", "metadata": {"domain": "jsa-deployment", "task_type": "deployment-guide", "skill_level": "C-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What CronJobs do JSA agents run?", "input": "List all JSA CronJobs and their schedules", "output": "JSA agents run these CronJobs for automation:\n\n**jsa-ci CronJobs:**\n1. **jsa-ci-log-sync** (*/15 * * * *)\n   - Syncs operational logs to CloudWatch/S3\n   - Feeds RAG pipeline for JADE training\n   - Script: /app/scripts/log_sync.py\n\n2. **jsa-ci-health-report** (0 8 * * *)\n   - Daily Slack summary at 8am UTC\n   - Reports: scans run, findings, fix rate, escalations\n   - Script: /app/scripts/health_report.py\n\n**jsa-devsecops CronJobs:**\n1. **jsa-devsecops-log-sync** (*/15 * * * *)\n   - Same as jsa-ci, syncs to RAG pipeline\n\n2. **jsa-devsecops-health-report** (0 8 * * *)\n   - Daily Slack summary for DevSecOps domains\n\n3. **jsa-devsecops-cve-tracker** (0 6 * * *)\n   - Daily CVE scan at 6am UTC (before health report)\n   - Scans production container images with Trivy\n   - Reports HIGH/CRITICAL vulnerabilities to Slack\n   - Script: /app/scripts/cve_tracker.py\n\n**Pipeline Flow:**\n6am: CVE scan images -> 8am: Health summary -> Every 15min: Logs to RAG", "metadata": {"domain": "jsa-cronjobs", "task_type": "automation-schedule", "skill_level": "D-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "How does jsa-devsecops domain scheduler work?", "input": "Explain the domain scheduling in jsa-devsecops", "output": "jsa-devsecops uses a priority-based domain scheduler (src/scheduler.py):\n\n**Priority Levels:**\n- CRITICAL (1 min interval): kubernetes, policy\n- HIGH (5 min interval): iac, cloud-aws, cloud-azure, cloud-gcp\n- MEDIUM (15 min interval): secrets, compliance\n\n**Scheduler Logic:**\n```python\nclass DomainScheduler:\n    DOMAIN_PRIORITIES = {\n        'kubernetes': 'CRITICAL',  # GuidePoint specialty\n        'policy': 'CRITICAL',      # OPA/Gatekeeper/Kyverno\n        'iac': 'HIGH',\n        'cloud-aws': 'HIGH',\n        'secrets': 'MEDIUM',\n        'compliance': 'MEDIUM'\n    }\n```\n\n**Scheduling Flow:**\n1. Agent loop calls scheduler.domains_to_scan()\n2. Returns list of domains past their scan interval\n3. Agent runs analyzers for each domain\n4. scheduler.mark_scanned(domain) updates timestamp\n5. scheduler.next_scan_time() determines sleep duration\n\nThis ensures Kubernetes and Policy issues are caught within 1 minute while less critical domains are checked periodically.", "metadata": {"domain": "jsa-devsecops", "task_type": "scheduler-design", "skill_level": "C-rank", "agent": "jsa-devsecops"}}
{"instruction": "What analyzers does jsa-devsecops have?", "input": "List all analyzers in jsa-devsecops by domain", "output": "jsa-devsecops analyzers are in src/analyzers/ with domain prefixes:\n\n**Kubernetes (k8s_*):**\n- k8s_kubernetes_analyzer.py - Main K8s security analyzer\n- k8s_pod_analyzer.py - Pod security analysis\n- k8s_deployment_analyzer.py - Deployment misconfigs\n- k8s_service_analyzer.py - Service exposure risks\n- k8s_node_analyzer.py - Node security posture\n- k8s_networkpolicy.py - NetworkPolicy coverage\n- k8s_rbac.py - RBAC over-permissions\n- k8s_secrets.py - K8s secrets exposure\n- k8s_pod_security.py - PSS/PSP compliance\n- k8s_probes.py - Missing health probes\n- k8s_resources.py - Missing resource limits\n- k8s_images.py - Image security (tags, registries)\n\n**Policy (policy_*):**\n- policy_rego_analyzer.py - OPA/Rego policy analysis\n- policy_constraint_analyzer.py - Gatekeeper constraints\n- policy_coverage_analyzer.py - Policy coverage gaps\n- policy_conflict_detector.py - Policy conflicts\n\n**Cloud (cloud_*):**\n- cloud_iam_analyzer.py - IAM policy analysis\n- cloud_s3_analyzer.py - S3 bucket security\n- cloud_ec2_analyzer.py - EC2 security groups\n- cloud_vpc_analyzer.py - VPC configurations\n- cloud_guardduty_analyzer.py - GuardDuty findings\n- cloud_securityhub_analyzer.py - Security Hub integration\n\n**IaC (iac_*):**\n- iac_terraform_analyzer.py - Terraform analysis\n- iac_helm_analyzer.py - Helm chart analysis\n- iac_cloudformation_analyzer.py - CFN analysis\n- iac_drift_detector.py - Infrastructure drift\n- iac_compliance_checker.py - IaC compliance\n\n**Secrets (secrets_*):**\n- secrets_rotation_analyzer.py - Rotation compliance\n- secrets_exposure_analyzer.py - Exposure detection\n- secrets_encryption_analyzer.py - Encryption at rest\n\n**Compliance (compliance_*):**\n- compliance_gap_analyzer.py - Framework gap analysis\n- compliance_control_mapper.py - Control mapping\n- compliance_evidence_collector.py - Audit evidence", "metadata": {"domain": "jsa-devsecops", "task_type": "analyzer-inventory", "skill_level": "C-rank", "agent": "jsa-devsecops"}}
{"instruction": "What watchers does jsa-devsecops have?", "input": "List all watchers in jsa-devsecops by domain", "output": "jsa-devsecops watchers are in src/watchers/ for real-time monitoring:\n\n**Kubernetes (k8s_*):**\n- k8s_events.py - Watch K8s events for security issues\n- k8s_admission.py - Admission webhook events\n- k8s_audit.py - Audit log monitoring\n- k8s_drift.py - Configuration drift detection\n- k8s_log_watcher.py - Pod log analysis\n\n**Policy (policy_*):**\n- policy_gatekeeper.py - Gatekeeper constraint violations\n- policy_kyverno.py - Kyverno policy reports\n- policy_conftest.py - Conftest policy changes\n\n**Cloud (cloud_*):**\n- cloud_iam_watcher.py - IAM changes\n- cloud_s3_watcher.py - S3 bucket changes\n- cloud_ec2_watcher.py - EC2/SG changes\n- cloud_vpc_watcher.py - VPC modifications\n\n**IaC (iac_*):**\n- iac_terraform_watcher.py - Terraform state changes\n- iac_helm_watcher.py - Helm release changes\n- iac_cloudformation_watcher.py - CFN stack events\n\n**Secrets (secrets_*):**\n- secrets_vault_watcher.py - Vault secret access\n- secrets_k8s_secrets_watcher.py - K8s secret changes\n- secrets_aws_secrets_watcher.py - AWS Secrets Manager\n\nWatchers run in the main agent loop and trigger immediate analysis when events occur.", "metadata": {"domain": "jsa-devsecops", "task_type": "watcher-inventory", "skill_level": "C-rank", "agent": "jsa-devsecops"}}
{"instruction": "What compliance templates does jsa-devsecops include?", "input": "List compliance framework templates", "output": "jsa-devsecops includes compliance templates in src/templates/:\n\n**Policy Templates (policy_*):**\n- policy_pss.py - Pod Security Standards (baseline, restricted)\n- policy_cis.py - CIS Kubernetes Benchmarks\n- policy_nist.py - NIST 800-53 controls\n- policy_soc2.py - SOC2 security controls\n- policy_pci.py - PCI-DSS requirements\n\n**Compliance Frameworks (compliance_*):**\n- compliance_cis.py - CIS benchmark mappings\n- compliance_nist.py - NIST 800-53 Rev5\n- compliance_soc2.py - SOC2 Type II\n- compliance_pci.py - PCI-DSS v4.0\n- compliance_hipaa.py - HIPAA Security Rule\n- compliance_fedramp.py - FedRAMP controls\n\n**Usage:**\nTemplates provide:\n- Control definitions and requirements\n- Mapping to scanner findings\n- Remediation guidance\n- Evidence collection requirements\n- Gap analysis reports\n\nThe compliance_mapper_npc.py uses these templates to generate compliance reports from scan findings.", "metadata": {"domain": "jsa-devsecops", "task_type": "compliance-templates", "skill_level": "C-rank", "agent": "jsa-devsecops"}}
{"instruction": "How do jsa-ci and jsa-devsecops coordinate?", "input": "Explain agent coordination and handoffs", "output": "jsa-ci and jsa-devsecops coordinate through GP-Copilot state management:\n\n**Division of Responsibility:**\n- jsa-ci: Code-level issues (runs on PR/commit events)\n- jsa-devsecops: Infrastructure issues (runs 24/7 on schedule)\n\n**State Sharing via GP-Copilot:**\n```\nGP-PROJECTS/{instance}/{slot}/jsa/\n├── scans/       # Both agents write scan results\n├── fixes/       # Both agents log fix attempts\n├── escalations/ # Shared escalation queue\n└── state.json   # Shared agent state\n```\n\n**Handoff Scenarios:**\n1. jsa-ci finds Dockerfile issue -> escalates to jsa-devsecops for K8s impact\n2. jsa-devsecops finds dependency CVE -> jsa-ci handles package upgrade\n3. Both detect same secret -> jsa-ci removes from code, jsa-devsecops rotates in Vault\n\n**Coordination Rules:**\n- Same finding = first agent claims ownership\n- Cross-domain = escalate to appropriate agent\n- B/S rank = both escalate to human\n\n**Log Sync Pipeline:**\nBoth agents sync logs every 15min -> GP-OPENSEARCH RAG -> JADE learns patterns", "metadata": {"domain": "jsa-coordination", "task_type": "agent-coordination", "skill_level": "B-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What is the jsa-devsecops src directory structure?", "input": "Show the flattened jsa-devsecops source structure", "output": "jsa-devsecops/src/ uses a flat structure with domain prefixes:\n\n```\nsrc/\n├── main.py              # Entry point, CLI parsing\n├── agent.py             # Main agent loop (DevSecOpsAgent)\n├── config.py            # AgentConfig from environment\n├── scheduler.py         # Domain priority scheduler\n│\n├── scanners/            # External tool wrappers (12 NPCs)\n│   ├── trivy_scan_npc.py\n│   ├── kubescape_scan_npc.py\n│   ├── checkov_scan_npc.py\n│   └── ...\n│\n├── analyzers/           # Finding analyzers (47 files)\n│   ├── k8s_*.py         # Kubernetes analyzers\n│   ├── policy_*.py      # Policy analyzers\n│   ├── cloud_*.py       # Cloud analyzers\n│   ├── iac_*.py         # IaC analyzers\n│   ├── secrets_*.py     # Secrets analyzers\n│   └── compliance_*.py  # Compliance analyzers\n│\n├── fixers/              # Remediation fixers (33 files)\n│   ├── k8s_*.py         # Kubernetes fixers\n│   ├── policy_*.py      # Policy fixers\n│   ├── cloud_*.py       # Cloud fixers\n│   ├── iac_*.py         # IaC fixers\n│   └── secrets_*.py     # Secrets fixers\n│\n├── watchers/            # Real-time monitors (18 files)\n│   ├── k8s_*.py         # K8s event watchers\n│   ├── policy_*.py      # Policy watchers\n│   ├── cloud_*.py       # Cloud watchers\n│   ├── iac_*.py         # IaC watchers\n│   └── secrets_*.py     # Secrets watchers\n│\n└── templates/           # Compliance templates (11 files)\n    ├── policy_*.py      # Policy templates\n    └── compliance_*.py  # Framework templates\n```\n\nThis flat structure with prefixes matches jsa-ci's organization for consistency.", "metadata": {"domain": "jsa-devsecops", "task_type": "codebase-structure", "skill_level": "D-rank", "agent": "jsa-devsecops"}}
{"instruction": "What is the jsa-ci src directory structure?", "input": "Show the jsa-ci source structure", "output": "jsa-ci/src/ structure:\n\n```\nsrc/\n├── __init__.py\n├── main.py              # Entry point\n├── agent.py             # CISecurityAgent main loop\n├── base_npc.py          # BaseNPC abstract class\n├── jade_client.py       # JADE model client\n├── fix_orchestrator.py  # Multi-fixer coordination\n│\n├── config/              # Configuration\n│   └── agent_config.py\n│\n├── scanners/            # Scanner NPCs (7 tools)\n│   ├── gitleaks_scan_npc.py\n│   ├── bandit_scan_npc.py\n│   ├── semgrep_scan_npc.py\n│   ├── eslint_scan_npc.py\n│   ├── hadolint_scan_npc.py\n│   ├── gha_scanner_npc.py\n│   └── github_api_npc.py\n│\n├── fixers/              # Fixer NPCs\n│   ├── secrets_fixer_npc.py\n│   ├── dependency_fixer_npc.py\n│   ├── code_fixer_npc.py\n│   └── ci_fixer_npc.py\n│\n├── analyzers/           # Finding analyzers\n│   ├── severity_analyzer.py\n│   └── rank_classifier.py\n│\n├── watchers/            # Event watchers\n│   ├── github_webhook_watcher.py\n│   └── pr_watcher.py\n│\n└── knowledge/           # Knowledge base\n    └── vulnerability_patterns.py\n```\n\njsa-ci focuses on CI/CD pipeline security with fewer, more specialized NPCs.", "metadata": {"domain": "jsa-ci", "task_type": "codebase-structure", "skill_level": "D-rank", "agent": "jsa-ci"}}
{"instruction": "How does the CVE tracker CronJob work?", "input": "Explain the cve_tracker.py script", "output": "The CVE tracker (jsa-devsecops/scripts/cve_tracker.py) scans container images daily:\n\n**Schedule:** 0 6 * * * (6am UTC, before health report)\n\n**Flow:**\n1. Load image list from CVE_IMAGES env or defaults\n2. For each image, run: trivy image --severity HIGH,CRITICAL --format json\n3. Extract vulnerabilities from Trivy JSON output\n4. Generate summary report with counts\n5. Save JSON report to /data/state/cve-reports/\n6. Send Slack notification if webhook configured\n\n**Configuration (values.yaml):**\n```yaml\ncronjobs:\n  cveTracker:\n    enabled: true\n    schedule: \"0 6 * * *\"\n    severity: \"HIGH,CRITICAL\"\n    slack: true\n    images: \"app:v1,api:v2\"  # Optional override\n```\n\n**Slack Message Format:**\n- Header with status emoji (rotating_light/warning/check)\n- Per-image summary (CRITICAL/HIGH counts)\n- Top 5 CVEs across all images\n- Links to remediation\n\n**Exit Codes:**\n- 0: No HIGH/CRITICAL CVEs\n- 1: HIGH CVEs found\n- 2: CRITICAL CVEs found\n\nUsed by K8s Job to determine success/failure for alerting.", "metadata": {"domain": "jsa-devsecops", "task_type": "cronjob-details", "skill_level": "D-rank", "agent": "jsa-devsecops"}}
{"instruction": "What RBAC permissions do JSA agents need?", "input": "Describe JSA Kubernetes RBAC requirements", "output": "JSA agents need RBAC permissions based on their rank and domains:\n\n**jsa-ci RBAC (CI/CD focused):**\n```yaml\n- apiGroups: [\"\"]  # Read pods, configmaps, secrets\n  resources: [\"pods\", \"configmaps\", \"secrets\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"apps\"]\n  resources: [\"deployments\"]\n  verbs: [\"get\", \"list\", \"watch\", \"patch\"]  # For image updates\n```\n\n**jsa-devsecops RBAC (full K8s security):**\n```yaml\n# Core resources\n- apiGroups: [\"\", \"apps\", \"batch\"]\n  resources: [\"*\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n\n# Write permissions for fixes (C-rank)\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"services\", \"configmaps\", \"networkpolicies\"]\n  verbs: [\"patch\", \"update\"]\n\n# Policy resources\n- apiGroups: [\"constraints.gatekeeper.sh\", \"kyverno.io\"]\n  resources: [\"*\"]\n  verbs: [\"get\", \"list\", \"watch\", \"create\", \"patch\"]\n\n# RBAC analysis\n- apiGroups: [\"rbac.authorization.k8s.io\"]\n  resources: [\"roles\", \"rolebindings\", \"clusterroles\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n```\n\n**Rank-Based Permissions:**\n- E-rank: Read-only (get, list, watch)\n- D-rank: Limited write (patch safe resources)\n- C-rank: Standard write (most resources, with approval)\n- B-rank: Elevated (RBAC, policies, requires escalation)\n- S-rank: Admin (cluster-wide, human required)", "metadata": {"domain": "jsa-rbac", "task_type": "rbac-requirements", "skill_level": "C-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "How do I deploy both JSA agents to a namespace?", "input": "Full deployment commands for JSA agents", "output": "Deploy both JSA agents to the portfolio namespace:\n\n**1. Create namespace and secrets:**\n```bash\nkubectl create namespace portfolio\n\n# Slack webhook secret\nkubectl create secret generic slack-webhook \\\n  --namespace portfolio \\\n  --from-literal=webhook-url='https://hooks.slack.com/...'\n\n# GP-Copilot API key (if needed)\nkubectl create secret generic gpcopilot-api-key \\\n  --namespace portfolio \\\n  --from-literal=api-key='your-api-key'\n```\n\n**2. Deploy jsa-ci:**\n```bash\nhelm upgrade --install jsa-ci \\\n  ./GP-BEDROCK-AGENTS/charts/jsa-ci \\\n  --namespace portfolio \\\n  --set gpcopilot.instance=02-instance \\\n  --set gpcopilot.slot=slot-3 \\\n  --set notifications.slack.webhookUrlSecret.enabled=true\n```\n\n**3. Deploy jsa-devsecops:**\n```bash\nhelm upgrade --install jsa-devsecops \\\n  ./GP-BEDROCK-AGENTS/charts/jsa-devsecops \\\n  --namespace portfolio \\\n  --set gpcopilot.instance=02-instance \\\n  --set gpcopilot.slot=slot-3 \\\n  --set notifications.slack.webhookUrlSecret.enabled=true \\\n  --set cronjobs.cveTracker.images='myapp:v1\\,myapi:v2'\n```\n\n**4. Verify deployment:**\n```bash\nkubectl get pods -n portfolio\nkubectl get cronjobs -n portfolio\nkubectl logs -n portfolio deploy/jsa-ci\nkubectl logs -n portfolio deploy/jsa-devsecops\n```\n\n**5. Check CronJobs:**\n```bash\nkubectl get cronjobs -n portfolio\n# jsa-ci-log-sync, jsa-ci-health-report\n# jsa-devsecops-log-sync, jsa-devsecops-health-report, jsa-devsecops-cve-tracker\n```", "metadata": {"domain": "jsa-deployment", "task_type": "deployment-commands", "skill_level": "C-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What domains can jsa-devsecops enable or disable?", "input": "List configurable domains in jsa-devsecops", "output": "jsa-devsecops domains are configured in values.yaml:\n\n**Kubernetes Domain:**\n```yaml\ndomains:\n  kubernetes:\n    enabled: true\n    namespaces: [\"*\"]  # or [\"prod\", \"staging\"]\n    excludeNamespaces: [\"kube-system\", \"kube-public\"]\n```\n\n**Policy-as-Code Domain:**\n```yaml\n  policy:\n    enabled: true\n    frameworks:\n      opa: true\n      gatekeeper: true\n      kyverno: true\n      conftest: true\n```\n\n**Infrastructure-as-Code Domain:**\n```yaml\n  iac:\n    enabled: true\n    providers:\n      terraform: true\n      cloudformation: false\n      arm: false\n```\n\n**Cloud Security Domain:**\n```yaml\n  cloud:\n    enabled: true\n    providers:\n      aws:\n        enabled: true\n        credentialsSecret:\n          enabled: false\n          name: \"aws-credentials\"\n      azure:\n        enabled: false\n      gcp:\n        enabled: false\n```\n\n**Secrets Management Domain:**\n```yaml\n  secrets:\n    enabled: true\n    providers:\n      vault: false\n      awsSecretsManager: true\n      k8sSecrets: true\n```\n\n**Compliance Domain:**\n```yaml\n  compliance:\n    enabled: true\n    frameworks:\n      cis: true\n      nist: true\n      soc2: true\n      pci: false\n      hipaa: false\n      fedramp: false\n```\n\nDisabled domains skip their schedulers, analyzers, and fixers entirely.", "metadata": {"domain": "jsa-devsecops", "task_type": "domain-configuration", "skill_level": "D-rank", "agent": "jsa-devsecops"}}
{"instruction": "How does JSA rank classification work?", "input": "Explain the E/D/C/B/S rank system", "output": "JSA uses a rank system to determine automation level for findings:\n\n**E-Rank (95-100% confidence, auto-fix):**\n- Hardcoded secrets in code\n- Missing .gitignore entries\n- Unpinned GitHub Actions\n- Missing resource limits (obvious patterns)\n\n**D-Rank (70-90% confidence, auto-fix with logging):**\n- SQL injection (clear patterns)\n- XSS vulnerabilities\n- Dependency CVEs with known fixes\n- Basic K8s misconfigs (no securityContext)\n\n**C-Rank (40-70% confidence, requires approval):**\n- Complex multi-file fixes\n- NetworkPolicy generation\n- RBAC scope reduction\n- Terraform/IaC modifications\n- Policy creation (Gatekeeper, Kyverno)\n\n**B-Rank (20-40% confidence, escalate to human):**\n- Architecture changes\n- Cross-service modifications\n- Compliance gaps requiring business decisions\n- Performance vs security tradeoffs\n\n**S-Rank (0-5% confidence, human required):**\n- Org-wide policy decisions\n- Incident response\n- Zero-trust architecture design\n- Compliance attestations\n\n**Agent Behavior by Rank:**\n- E/D: Auto-fix immediately, log result\n- C: Send to Slack for approval, wait for response\n- B/S: Create escalation ticket, notify humans\n\nRank is determined by the agent's brain (JADE model) analyzing finding context.", "metadata": {"domain": "jsa-ranking", "task_type": "rank-system", "skill_level": "C-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What metrics do JSA agents expose?", "input": "Describe JSA Prometheus metrics", "output": "JSA agents expose Prometheus metrics on port 9100:\n\n**Common Metrics (both agents):**\n```\n# Scan metrics\njsa_scans_total{scanner=\"trivy\", status=\"success\"}\njsa_scan_duration_seconds{scanner=\"gitleaks\"}\njsa_findings_total{severity=\"CRITICAL\", domain=\"kubernetes\"}\n\n# Fix metrics\njsa_fixes_attempted_total{rank=\"D\", domain=\"secrets\"}\njsa_fixes_succeeded_total{rank=\"C\"}\njsa_fix_duration_seconds{fixer=\"dependency_fixer\"}\n\n# Escalation metrics\njsa_escalations_total{rank=\"B\", reason=\"architecture_change\"}\njsa_approval_wait_seconds{rank=\"C\"}\n\n# Agent health\njsa_agent_up{agent=\"jsa-devsecops\"}\njsa_last_scan_timestamp{domain=\"kubernetes\"}\njsa_queue_depth{type=\"pending_fixes\"}\n```\n\n**jsa-devsecops Specific:**\n```\njsa_domain_scan_interval_seconds{domain=\"policy\"}\njsa_watcher_events_total{watcher=\"k8s_events\"}\njsa_policy_violations_total{framework=\"gatekeeper\"}\n```\n\n**ServiceMonitor (for Prometheus Operator):**\n```yaml\nmetrics:\n  enabled: true\n  port: 9100\n  serviceMonitor:\n    enabled: true\n    interval: 30s\n    labels:\n      release: prometheus\n```\n\nMetrics feed Grafana dashboards for security posture visualization.", "metadata": {"domain": "jsa-monitoring", "task_type": "metrics-reference", "skill_level": "D-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "How does log sync work for RAG ingestion?", "input": "Explain the log_sync.py script", "output": "log_sync.py (in both agents' scripts/) syncs operational logs to RAG:\n\n**Schedule:** */15 * * * * (every 15 minutes)\n\n**Flow:**\n1. Read logs from /data/state/ (scans, fixes, escalations)\n2. Format as JSONL for RAG ingestion\n3. Upload to GP-OPENSEARCH/01-unprocessed/operational-logs/\n4. Optionally push to CloudWatch/S3\n\n**Log Types Synced:**\n```\n/data/state/\n├── scans/          # Scan result JSONs\n├── fixes/          # Fix attempt logs\n├── escalations/    # Escalation records\n└── cycles/         # Full cycle reports\n```\n\n**JSONL Format:**\n```json\n{\"timestamp\": \"2026-01-02T...\", \"agent\": \"jsa-ci\", \"type\": \"scan\", \"scanner\": \"gitleaks\", \"findings\": 3}\n{\"timestamp\": \"2026-01-02T...\", \"agent\": \"jsa-devsecops\", \"type\": \"fix\", \"domain\": \"kubernetes\", \"success\": true}\n```\n\n**RAG Pipeline:**\n```\nlog_sync.py -> GP-OPENSEARCH/01-unprocessed/\n            -> GP-OPENSEARCH/02-preparation-factory/\n            -> GP-OPENSEARCH/03-preprocessed/\n            -> GP-OPENSEARCH/04-ingesting/\n            -> ChromaDB (JADE RAG)\n```\n\nJADE learns from operational patterns to improve future decisions.", "metadata": {"domain": "jsa-logging", "task_type": "log-sync-design", "skill_level": "D-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What notifications can JSA agents send?", "input": "List JSA notification channels and triggers", "output": "JSA agents support multiple notification channels:\n\n**Slack Notifications:**\n```yaml\nnotifications:\n  slack:\n    enabled: true\n    webhookUrlSecret:\n      enabled: true\n      name: \"slack-webhook\"\n      key: \"webhook-url\"\n    channel: \"#security-alerts\"\n    severities: [CRITICAL, HIGH]\n```\n\n**Notification Types:**\n1. **Finding Alerts** - New CRITICAL/HIGH findings\n2. **C-Rank Approvals** - Interactive approve/deny buttons\n3. **Fix Results** - Success/failure notifications\n4. **Health Reports** - Daily summary (8am)\n5. **CVE Reports** - Daily image scan (6am)\n6. **Escalations** - B/S rank findings requiring human review\n\n**Email Notifications:**\n```yaml\n  email:\n    enabled: true\n    smtpHost: \"smtp.example.com\"\n    from: \"jsa@linkops.ai\"\n    to: [\"security-team@linkops.ai\"]\n```\n\n**PagerDuty Integration:**\n```yaml\n  pagerduty:\n    enabled: true\n    integrationKeySecret:\n      enabled: true\n      name: \"pagerduty-key\"\n    severities: [CRITICAL]  # Only page for critical\n```\n\n**Slack Message Examples:**\n- :rotating_light: CRITICAL: SQL Injection in api/users.py [Approve] [Deny]\n- :white_check_mark: Fixed 3 dependency CVEs in package.json\n- :warning: Daily Health: 5 scans, 12 findings, 80% fix rate", "metadata": {"domain": "jsa-notifications", "task_type": "notification-channels", "skill_level": "D-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "How does health_report.py work?", "input": "Explain the daily health report script", "output": "health_report.py generates daily Slack summaries for both agents:\n\n**Schedule:** 0 8 * * * (8am UTC daily)\n\n**Flow:**\n1. Parse logs from last 24 hours in /data/state/\n2. Count scans, findings by severity, fixes attempted/succeeded\n3. Calculate fix rate percentage\n4. Format Slack blocks message\n5. Send to SLACK_WEBHOOK_URL\n\n**Summary Data Collected:**\n```python\nsummary = {\n    'total_scans': 0,\n    'total_findings': 0,\n    'by_severity': {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0},\n    'by_rank': {'E': 0, 'D': 0, 'C': 0, 'B': 0, 'S': 0},\n    'fixes_attempted': 0,\n    'fixes_succeeded': 0,\n    'escalations': 0,\n    'errors': []\n}\n```\n\n**Health Status Logic:**\n- :rotating_light: Critical Findings - CRITICAL > 0\n- :warning: Degraded - errors present\n- :large_blue_circle: Operational - findings but no critical\n- :white_check_mark: Healthy - no findings\n\n**Slack Message Sections:**\n- Header with status emoji\n- Status and report time\n- Last 24 hours summary\n- Scan count, finding count\n- Critical/High counts\n- Fix rate percentage\n- Rank distribution\n- Error list (if any)", "metadata": {"domain": "jsa-cronjobs", "task_type": "health-report-design", "skill_level": "D-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What is the JSA agent main loop structure?", "input": "Explain the agent.py main loop", "output": "Both JSA agents run an async main loop in agent.py:\n\n**jsa-ci (CISecurityAgent):**\n```python\nasync def run(self):\n    while True:\n        # 1. Check for GitHub webhook events\n        events = await self.watcher.get_pending_events()\n        \n        for event in events:\n            # 2. Run relevant scanners\n            findings = await self.scan(event.target)\n            \n            # 3. Classify findings by rank\n            ranked = self.rank_classifier.classify(findings)\n            \n            # 4. Auto-fix E/D rank\n            for finding in ranked['E'] + ranked['D']:\n                await self.fix_orchestrator.fix(finding)\n            \n            # 5. Send C-rank for approval\n            for finding in ranked['C']:\n                await self.slack.request_approval(finding)\n            \n            # 6. Escalate B/S rank\n            for finding in ranked['B'] + ranked['S']:\n                await self.escalate(finding)\n        \n        await asyncio.sleep(10)  # Poll interval\n```\n\n**jsa-devsecops (DevSecOpsAgent):**\n```python\nasync def run(self):\n    while True:\n        # 1. Get domains ready to scan\n        domains = self.scheduler.domains_to_scan()\n        \n        for domain in domains:\n            # 2. Run domain analyzers\n            findings = await self.analyze_domain(domain)\n            \n            # 3. Process findings by rank\n            await self.process_findings(findings)\n            \n            # 4. Mark domain scanned\n            self.scheduler.mark_scanned(domain)\n        \n        # 5. Check watchers for real-time events\n        await self.check_watchers()\n        \n        # 6. Sleep until next domain ready\n        sleep_time = self.scheduler.next_scan_time()\n        await asyncio.sleep(min(sleep_time, 60))\n```\n\nBoth agents emit Prometheus metrics throughout the loop.", "metadata": {"domain": "jsa-architecture", "task_type": "agent-loop-design", "skill_level": "C-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "What Helm chart templates exist for JSA agents?", "input": "List all Helm templates for JSA", "output": "Both JSA Helm charts have these templates in charts/{agent}/templates/:\n\n**Common Templates:**\n- deployment.yaml - Main agent pod\n- service.yaml - ClusterIP for metrics\n- serviceaccount.yaml - K8s ServiceAccount\n- configmap.yaml - Agent configuration\n- secret.yaml - Sensitive config (if not using external)\n- rbac.yaml - ClusterRole and ClusterRoleBinding\n- networkpolicy.yaml - Pod traffic control\n- servicemonitor.yaml - Prometheus scraping\n- _helpers.tpl - Template helper functions\n\n**jsa-ci Specific:**\n- cronjob-log-sync.yaml - Log sync every 15min\n- cronjob-health-report.yaml - Daily 8am report\n\n**jsa-devsecops Specific:**\n- cronjob-log-sync.yaml - Log sync every 15min\n- cronjob-health-report.yaml - Daily 8am report\n- cronjob-cve-tracker.yaml - Daily 6am CVE scan\n\n**Chart Structure:**\n```\ncharts/jsa-{agent}/\n├── Chart.yaml           # Chart metadata\n├── values.yaml          # Default values\n├── templates/\n│   ├── _helpers.tpl\n│   ├── deployment.yaml\n│   ├── service.yaml\n│   ├── serviceaccount.yaml\n│   ├── configmap.yaml\n│   ├── rbac.yaml\n│   ├── networkpolicy.yaml\n│   ├── servicemonitor.yaml\n│   ├── cronjob-*.yaml\n│   └── NOTES.txt\n└── README.md\n```", "metadata": {"domain": "jsa-deployment", "task_type": "helm-templates", "skill_level": "D-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
{"instruction": "How do I check JSA agent status?", "input": "Commands to verify JSA deployment health", "output": "Verify JSA agent deployment and health:\n\n**Check Pods:**\n```bash\n# List running agents\nkubectl get pods -n portfolio -l app.kubernetes.io/name=jsa-ci\nkubectl get pods -n portfolio -l app.kubernetes.io/name=jsa-devsecops\n\n# Check pod status\nkubectl describe pod -n portfolio -l app.kubernetes.io/name=jsa-devsecops\n```\n\n**Check Logs:**\n```bash\n# Live logs\nkubectl logs -n portfolio deploy/jsa-ci -f\nkubectl logs -n portfolio deploy/jsa-devsecops -f\n\n# Last 100 lines\nkubectl logs -n portfolio deploy/jsa-devsecops --tail=100\n```\n\n**Check CronJobs:**\n```bash\n# List all CronJobs\nkubectl get cronjobs -n portfolio\n\n# Check last job run\nkubectl get jobs -n portfolio --sort-by=.metadata.creationTimestamp\n\n# View CronJob logs\nkubectl logs -n portfolio job/jsa-devsecops-cve-tracker-xxxxx\n```\n\n**Check Metrics:**\n```bash\n# Port-forward to metrics\nkubectl port-forward -n portfolio deploy/jsa-devsecops 9100:9100\n\n# Curl metrics\ncurl http://localhost:9100/metrics | grep jsa_\n```\n\n**Health Command:**\n```bash\n# Run health check\nkubectl exec -n portfolio deploy/jsa-devsecops -- python3 /app/main.py health\n```", "metadata": {"domain": "jsa-operations", "task_type": "health-check-commands", "skill_level": "D-rank", "agents": ["jsa-ci", "jsa-devsecops"]}}
