{{- if .Values.gatekeeper.enabled }}
# Constraint Template for allowed registries
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sallowedregistries
  namespace: {{ .Release.Namespace }}
spec:
  crd:
    spec:
      names:
        kind: K8sAllowedRegistries
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowedRegistries:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sallowedregistries

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          some i
          image := input.review.object.spec.containers[i].image
          not startswith(image, input.parameters.allowedRegistries[_])
          msg := sprintf("Image '%v' is not from an allowed registry", [image])
        }
---
# Constraint for allowed registries
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sAllowedRegistries
metadata:
  name: allowed-registries
  namespace: {{ .Release.Namespace }}
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaces: [{{ .Release.Namespace | quote }}]
  parameters:
    allowedRegistries:
      - "ghcr.io/"
      - "chromadb/"
      - "busybox:"
---
# Constraint Template for requiring signed images
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiresignedimages
  namespace: {{ .Release.Namespace }}
spec:
  crd:
    spec:
      names:
        kind: K8sRequireSignedImages
      validation:
        openAPIV3Schema:
          type: object
          properties:
            exemptNamespaces:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiresignedimages

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          not input.review.object.metadata.namespace in input.parameters.exemptNamespaces
          some i
          image := input.review.object.spec.containers[i].image
          startswith(image, "ghcr.io/")
          # This is a simplified check - in production, you'd verify cosign signatures
          not contains(image, "@sha256:")
          msg := sprintf("Image '%v' must be signed and referenced by digest", [image])
        }
---
# Constraint for requiring signed images
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequireSignedImages
metadata:
  name: require-signed-images
  namespace: {{ .Release.Namespace }}
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaces: [{{ .Release.Namespace | quote }}]
  parameters:
    exemptNamespaces:
      - "kube-system"
      - "gatekeeper-system"
---
# Constraint Template for blocking privileged containers
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sblockprivileged
  namespace: {{ .Release.Namespace }}
spec:
  crd:
    spec:
      names:
        kind: K8sBlockPrivileged
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sblockprivileged

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          some i
          container := input.review.object.spec.containers[i]
          container.securityContext.privileged == true
          msg := sprintf("Container '%v' cannot run in privileged mode", [container.name])
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          some i
          container := input.review.object.spec.containers[i]
          container.securityContext.allowPrivilegeEscalation == true
          msg := sprintf("Container '%v' cannot allow privilege escalation", [container.name])
        }
---
# Constraint for blocking privileged containers
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sBlockPrivileged
metadata:
  name: block-privileged-containers
  namespace: {{ .Release.Namespace }}
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaces: [{{ .Release.Namespace | quote }}]
---
# Constraint Template for requiring resource limits
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequireresources
  namespace: {{ .Release.Namespace }}
spec:
  crd:
    spec:
      names:
        kind: K8sRequireResources
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequireresources

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          some i
          container := input.review.object.spec.containers[i]
          not container.resources.limits.memory
          msg := sprintf("Container '%v' must have memory limits", [container.name])
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          some i
          container := input.review.object.spec.containers[i]
          not container.resources.limits.cpu
          msg := sprintf("Container '%v' must have CPU limits", [container.name])
        }
---
# Constraint for requiring resource limits
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequireResources
metadata:
  name: require-resource-limits
  namespace: {{ .Release.Namespace }}
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaces: [{{ .Release.Namespace | quote }}]
{{- end }}