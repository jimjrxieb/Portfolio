apiVersion: apps/v1
kind: Deployment
metadata:
  name: portfolio-api
  namespace: portfolio
  labels:
    app: portfolio-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: portfolio-api
  template:
    metadata:
      labels:
        app: portfolio-api
    spec:
      # JSA-FIX: CKV_K8S_38 - Don't mount service account token
      automountServiceAccountToken: false
      securityContext:
        runAsNonRoot: true
        runAsUser: 10001
        runAsGroup: 10001
        fsGroup: 10001
        seccompProfile:
          type: RuntimeDefault
      initContainers:
        # Wait for ChromaDB to be ready before syncing
        - name: wait-for-chromadb
          # JSA-FIX: CKV_K8S_43 - Use image digest instead of tag
          image: busybox@sha256:355b3a1bf5609da364166913878a8508d4ba30572d02020a97028c75477e24ff
          # JSA-FIX: CKV_K8S_15 - Always pull for security patches
          imagePullPolicy: Always
          # JSA-FIX: CKV_K8S_10,11,12,13 - Resource limits for init container
          resources:
            requests:
              cpu: "50m"
              memory: "32Mi"
            limits:
              cpu: "100m"
              memory: "64Mi"
          securityContext:
            runAsNonRoot: true
            runAsUser: 10001
            allowPrivilegeEscalation: false
            # JSA-FIX: CKV_K8S_22 - Read-only filesystem
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          command:
            - sh
            - -c
            - |
              echo "Waiting for ChromaDB..."
              for i in $(seq 1 60); do
                if wget -q -O- http://chromadb:8000/api/v1/heartbeat 2>/dev/null; then
                  echo "ChromaDB ready!"
                  exit 0
                fi
                sleep 2
              done
              echo "ChromaDB timeout - continuing anyway"
              exit 0
        # Sync RAG data to ChromaDB on every pod start
        - name: rag-sync
          # JSA-FIX: CKV_K8S_43 - Use image digest instead of tag
          image: python@sha256:1dd3dca85e22886e44fcad1bb7ccab6691dfa83db52214cf9e20696e095f3e36
          # JSA-FIX: CKV_K8S_15 - Always pull for security patches
          imagePullPolicy: Always
          # JSA-FIX: CKV_K8S_10,11,12,13 - Resource limits for init container
          resources:
            requests:
              cpu: "100m"
              memory: "256Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          securityContext:
            runAsNonRoot: true
            runAsUser: 10001
            allowPrivilegeEscalation: false
            # JSA-FIX: CKV_K8S_22 - Read-only filesystem
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          env:
            - name: CHROMADB_URL
              value: "http://chromadb:8000"
            - name: OLLAMA_URL
              value: "http://host.docker.internal:11434"
            - name: EMBED_MODEL
              value: "nomic-embed-text"
            - name: HOME
              value: "/tmp"
            - name: PIP_CACHE_DIR
              value: "/tmp/.cache/pip"
          command:
            - /bin/bash
            - -c
            - |
              echo "=== RAG SYNC INIT ==="
              pip install --no-cache-dir --quiet chromadb==0.5.18 requests
              python3 << 'EOF'
              import os, hashlib, requests, chromadb, re
              from datetime import datetime
              from pathlib import Path

              CHROMADB_URL = os.environ.get("CHROMADB_URL")
              OLLAMA_URL = os.environ.get("OLLAMA_URL")
              EMBED_MODEL = os.environ.get("EMBED_MODEL", "nomic-embed-text")

              def get_embedding(text):
                  try:
                      r = requests.post(f"{OLLAMA_URL}/api/embeddings",
                          json={"model": EMBED_MODEL, "prompt": text}, timeout=60)
                      return r.json()["embedding"]
                  except: return [0.0] * 768

              def chunk_text(text, size=1000, overlap=200):
                  words = text.split()
                  if len(words) <= size: return [text]
                  chunks, start = [], 0
                  while start < len(words):
                      chunks.append(' '.join(words[start:start+size]))
                      start += size - overlap
                      if start + size >= len(words): break
                  return chunks

              print(f"Connecting to {CHROMADB_URL}...")
              match = re.match(r'http://([^:]+):(\d+)', CHROMADB_URL)
              client = chromadb.HttpClient(host=match.group(1), port=int(match.group(2)))

              # Check if collection exists and has data - if so, skip sync entirely
              try:
                  col = client.get_collection("portfolio_knowledge")
                  count = col.count()
                  if count > 0:
                      print(f"Collection already has {count} docs - skipping sync")
                      import sys
                      sys.exit(0)
              except Exception as e:
                  print(f"Collection check failed ({e}) - will create new")

              # Delete old and create fresh
              try: client.delete_collection("portfolio_knowledge")
              except: pass

              col = client.get_or_create_collection("portfolio_knowledge",
                  metadata={"description": "Portfolio KB", "created_at": datetime.now().isoformat()})

              RAG_DIR = Path("/rag-data")
              files = list(RAG_DIR.glob("*.md"))
              print(f"Found {len(files)} RAG files")

              total = 0
              for f in files:
                  try:
                      content = f.read_text()
                      content = ''.join(c for c in content if ord(c) >= 32 or c in '\n\t').strip()
                      if len(content) < 100: continue
                      chunks = chunk_text(content)
                      for i, chunk in enumerate(chunks):
                          doc_id = hashlib.sha256(f"{f.name}_{i}".encode()).hexdigest()
                          col.add(ids=[doc_id], embeddings=[get_embedding(chunk)],
                              documents=[chunk], metadatas=[{"source": f.name, "chunk": i}])
                          total += 1
                      print(f"  {f.name}: {len(chunks)} chunks")
                  except Exception as e: print(f"  {f.name}: ERROR {e}")

              print(f"Synced {total} docs to ChromaDB")
              EOF
          volumeMounts:
            - name: rag-data
              mountPath: /rag-data
              readOnly: true
            - name: tmp
              mountPath: /tmp
      containers:
        - name: api
          # JSA-FIX: CKV_K8S_43 - Use image digest instead of tag
          image: ghcr.io/jimjrxieb/portfolio-api@sha256:47761c56adb9eae2029e46c4fd2f69cceb6bf67c32beab64877e66a7948620f5
          # JSA-FIX: CKV_K8S_15 - Always pull to get security patches
          imagePullPolicy: Always
          securityContext:
            runAsNonRoot: true
            runAsUser: 10001
            runAsGroup: 10001
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: LLM_PROVIDER
              value: "claude"
            - name: LLM_MODEL
              value: "claude-3-haiku-20240307"
            - name: OLLAMA_URL
              value: "http://host.docker.internal:11434"
            - name: EMBED_MODEL
              value: "nomic-embed-text"
            - name: API_PORT
              value: "8000"
            - name: API_HOST
              value: "0.0.0.0"
            - name: CHROMA_HOST
              value: "chromadb"
            - name: CHROMA_PORT
              value: "8000"
            - name: CHROMA_URL
              value: "http://chromadb:8000"
            - name: RAG_NAMESPACE
              value: "portfolio"
            - name: DATA_DIR
              value: "/data"
            - name: CLAUDE_API_KEY
              valueFrom:
                secretKeyRef:
                  name: portfolio-api-secrets
                  key: CLAUDE_API_KEY
          resources:
            requests:
              cpu: "200m"
              memory: "512Mi"
            limits:
              cpu: "1"
              memory: "2Gi"
          # JSA-FIX: CKV_K8S_8 - Liveness probe for self-healing
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 15
            timeoutSeconds: 5
            failureThreshold: 3
          # JSA-FIX: CKV_K8S_9 - Readiness probe for traffic routing
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
          volumeMounts:
            - name: data
              mountPath: /data
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: data
          emptyDir: {}
        - name: tmp
          emptyDir: {}
        - name: rag-data
          configMap:
            name: rag-data
---
apiVersion: v1
kind: Service
metadata:
  name: portfolio-api
  namespace: portfolio
spec:
  selector:
    app: portfolio-api
  ports:
    - port: 8000
      targetPort: 8000
      protocol: TCP
  type: ClusterIP
